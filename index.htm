<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Adverb-Man: O Labirinto dos Advérbios</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #000020;
            --primary-color: #FFFF00;
            --wall-color: #0000FF;
            --path-color: #000;
            --text-color: #FFFFFF;
            --correct-color: #00FF00;
            --incorrect-color: #FF0000;
            --ghost-color-1: #FF00FF;
            --ghost-color-2: #00FFFF;
            --ghost-color-3: #FFB8FF;
            --ghost-color-4: #FF5733;
            --vulnerable-ghost-color: #2196F3;
        }

        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 1rem;
            background-color: #111;
            border: 3px solid var(--wall-color);
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
        }
        
        #start-screen {
            display: flex;
        }
        #game-container, #end-screen, #ranking-screen {
            display: none;
        }


        #start-screen h1, #end-screen h1, #ranking-screen h1 {
            font-size: clamp(1.2rem, 5vw, 2.5rem);
            color: var(--primary-color);
            margin-bottom: 1.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
            width: 100%;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: clamp(0.8rem, 3vw, 1rem);
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.5rem;
            font-family: 'Press Start 2P', cursive;
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 2px solid var(--wall-color);
            border-radius: 5px;
            font-size: clamp(0.8rem, 3vw, 1rem);
        }

        .action-button {
            padding: 0.75rem 1.5rem;
            font-family: 'Press Start 2P', cursive;
            background-color: var(--primary-color);
            color: var(--bg-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: clamp(1rem, 4vw, 1.2rem);
            margin-top: 1rem;
        }
        
        #game-container {
            flex-direction: column;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: space-between;
        }
        
        #game-container-inner {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 0.3rem 0.5rem;
            font-size: clamp(0.6rem, 2.5vw, 1rem);
            background-color: #111;
            border-radius: 10px 10px 0 0;
            border: 2px solid var(--wall-color);
            border-bottom: none;
            box-sizing: border-box;
            flex-wrap: wrap;
        }

        #hud span {
            margin: 2px 5px;
        }

        #lives {
            color: #FF69B4;
        }

        #question-display {
            text-align: center;
            width: 100%;
            padding: 0.5rem;
            font-size: clamp(0.6rem, 2.5vw, 0.9rem);
            background-color: #111;
            border-top: none;
            border-bottom: none;
            box-sizing: border-box;
            color: var(--primary-color);
        }

        canvas {
            background-color: var(--path-color);
            border: 2px solid var(--wall-color);
            width: 100%;
            height: auto;
            aspect-ratio: 20 / 15;
            border-radius: 0 0 10px 10px;
            flex-grow: 1;
            min-height: 0;
        }

        #mobile-controls {
            display: none;
            width: 100%;
            padding: 1rem 0;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
            max-width: 200px;
            justify-items: center;
        }
        
        #mobile-controls button {
            background-color: var(--wall-color);
            color: var(--text-color);
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            font-size: clamp(1.5rem, 5vw, 2rem);
            width: clamp(50px, 15vw, 70px);
            height: clamp(50px, 15vw, 70px);
            font-family: 'Press Start 2P', cursive;
            user-select: none;
        }
        
        #mobile-controls .up { grid-column: 2; grid-row: 1; }
        #mobile-controls .left { grid-column: 1; grid-row: 2; }
        #mobile-controls .right { grid-column: 3; grid-row: 2; }
        #mobile-controls .down { grid-column: 2; grid-row: 2; }
        
        #end-screen h2, #ranking-screen h2 {
            margin-bottom: 1rem;
        }

        #leaderboard, #ranking-board {
            width: 100%;
            margin-top: 1.5rem;
            font-size: clamp(0.7rem, 2.5vw, 0.9rem);
        }
        
        #leaderboard h3, #ranking-board h3 {
             color: var(--primary-color);
             margin-bottom: 1rem;
        }

        #leaderboard ol, #ranking-board ol {
            list-style: none;
            padding: 0;
            text-align: left;
        }
        
        #leaderboard li, #ranking-board li {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            border-radius: 5px;
        }

        #leaderboard li:nth-child(odd), #ranking-board li:nth-child(odd) {
            background-color: #222;
        }
        
        .score-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 50%;
        }

    </style>
</head>
<body>

    <div id="start-screen" class="screen">
        <h1>Adverb-Man</h1>
        <div class="form-group">
            <label for="playerName">Nome:</label>
            <input type="text" id="playerName" placeholder="Digite seu nome">
        </div>
        <div class="form-group">
            <label for="playerClass">Turma:</label>
            <select id="playerClass">
                <option value="5A">5º Ano A</option>
                <option value="5B">5º Ano B</option>
            </select>
        </div>
        <button id="start-button" class="action-button">Começar a Jogar</button>
        <button id="ranking-button" class="action-button">Ver Ranking</button>
    </div>

    <div id="game-container">
      <div id="game-container-inner">
        <div id="hud">
            <span id="score">Pontos: 0</span>
            <span id="level">Nível: 1</span>
            <span id="lives">Vidas: ❤️❤️❤️❤️❤️</span>
        </div>
        <div id="question-display">Carregando pergunta...</div>
        <canvas id="gameCanvas"></canvas>
      </div>
      <div id="mobile-controls">
        <button class="up">▲</button>
        <button class="left">◄</button>
        <button class="down">▼</button>
        <button class="right">►</button>
      </div>
    </div>
    
    <div id="end-screen" class="screen">
        <h1 id="end-title">Fim de Jogo!</h1>
        <h2 id="final-score">Sua Pontuação: 0</h2>
        <p id="game-duration"></p>
        <p id="game-date-time"></p>
        <div id="leaderboard">
            <h3>Melhores 5 Pontuações</h3>
            <ol id="leaderboard-list"></ol>
        </div>
        <button id="restart-button" class="action-button">Jogar Novamente</button>
    </div>

    <div id="ranking-screen" class="screen">
        <h1>Melhores 20 Pontuações</h1>
        <div id="ranking-board">
            <ol id="ranking-list"></ol>
        </div>
        <button id="back-to-start-button" class="action-button">Voltar</button>
    </div>

    <script type="module">
      document.addEventListener('DOMContentLoaded', () => {
        // =================================================================
        // MÓDULO DE CONFIGURAÇÃO (config.js)
        // =================================================================
        const Config = {
            SCRIPT_URL: "https://script.google.com/macros/s/AKfycbxMLunxIV6qQD4Fm90TLQTE7Fj0sbU0FWlVkhDN3_irAWufbHiMarfTIYuTzgwl3KnZfg/exec",
            MAZE_LAYOUT: [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
                [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1],
                [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1],
                [1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1],
                [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            ],
            PLAYER_START_POS: { x: 1, y: 1 },
            GHOST_START_POS: { x: 18, y: 1 },
            ADVERBS: {
                afirmacao: ["sim", "certamente", "realmente", "definitivamente", "verdadeiramente", "efetivamente", "claramente", "seguramente", "decerto"],
                duvida: ["talvez", "quiçá", "possivelmente", "provavelmente", "eventualmente", "acaso"],
                negacao: ["não", "nunca", "jamais", "tampouco"],
                tempo: ["hoje", "ontem", "amanhã", "agora", "cedo", "tarde", "logo", "imediatamente", "brevemente", "recentemente", "outrora", "anteriormente", "posteriormente", "ultimamente"],
                frequencia: ["sempre", "frequentemente", "raramente", "ocasionalmente", "diariamente", "periodicamente", "constantemente", "esporadicamente"],
                modo: ["bem", "mal", "depressa", "devagar", "rapidamente", "lentamente", "cuidadosamente", "calmamente", "facilmente", "suavemente"],
                lugar: ["aqui", "ali", "lá", "cá", "perto", "longe", "acima", "abaixo", "dentro", "fora", "adiante", "atrás", "acolá"],
                intensidade: ["muito", "pouco", "bastante", "demais", "mais", "menos", "extremamente", "totalmente", "completamente", "absolutamente"]
            }
        };

        // =================================================================
        // MÓDULO DE ELEMENTOS DA UI (ui.js)
        // =================================================================
        const UI = {
            startScreen: document.getElementById('start-screen'),
            gameContainer: document.getElementById('game-container'),
            endScreen: document.getElementById('end-screen'),
            rankingScreen: document.getElementById('ranking-screen'),
            startButton: document.getElementById('start-button'),
            restartButton: document.getElementById('restart-button'),
            rankingButton: document.getElementById('ranking-button'),
            backToStartButton: document.getElementById('back-to-start-button'),
            playerNameInput: document.getElementById('playerName'),
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d'),
            scoreEl: document.getElementById('score'),
            levelEl: document.getElementById('level'),
            livesEl: document.getElementById('lives'),
            questionEl: document.getElementById('question-display'),
            mobileControls: document.getElementById('mobile-controls'),
            finalScoreEl: document.getElementById('final-score'),
            gameDurationEl: document.getElementById('game-duration'),
            gameDateTimeEl: document.getElementById('game-date-time'),
            leaderboardListEl: document.getElementById('leaderboard-list'),
            rankingListEl: document.getElementById('ranking-list'),
            endTitleEl: document.getElementById('end-title'),
            hud: document.getElementById('hud'),
        };

        // =================================================================
        // MÓDULO DE ESTADO DO JOGO (gameState.js)
        // =================================================================
        const GameState = {
            score: 0,
            level: 1,
            lives: 5,
            player: null,
            enemies: [],
            answers: [],
            collectibleStars: [],
            currentQuestion: null,
            powerUp: null,
            gameRunning: true,
            tileSize: 0,
            playerName: "Ana",
            isPoweredUp: false,
            powerUpTimer: null,
            gameStartTime: null,
            levelTimer: null,
        };

        // =================================================================
        // MÓDULO DE CLASSES (classes.js)
        // =================================================================
        class Player {
            constructor(x, y, size, speed) { this.x = x; this.y = y; this.size = size; this.speed = speed; this.dx = 0; this.dy = 0; this.visible = true; }
            draw() {
                if (!this.visible) return;
                const s = this.size; UI.ctx.save(); UI.ctx.translate(this.x, this.y);
                UI.ctx.fillStyle = '#A52A2A'; UI.ctx.beginPath(); UI.ctx.arc(0, -s/4, s/2.5, 0, Math.PI * 2); UI.ctx.fill(); UI.ctx.fillRect(-s/2.5, -s/4, s/1.25, s/4);
                UI.ctx.fillStyle = '#FFDAB9'; UI.ctx.beginPath(); UI.ctx.arc(0, 0, s / 3, 0, Math.PI * 2); UI.ctx.fill();
                UI.ctx.fillStyle = 'black'; UI.ctx.beginPath(); UI.ctx.arc(-s / 10, -s / 20, s / 20, 0, Math.PI * 2); UI.ctx.arc(s / 10, -s / 20, s / 20, 0, Math.PI * 2); UI.ctx.fill();
                UI.ctx.fillStyle = '#87CEEB'; UI.ctx.beginPath(); UI.ctx.moveTo(-s/4, s/4); UI.ctx.lineTo(s/4, s/4); UI.ctx.lineTo(s/3, s/2); UI.ctx.lineTo(-s/3, s/2); UI.ctx.closePath(); UI.ctx.fill();
                UI.ctx.restore();
            }
            update() {
                const nextX = this.x + this.dx; const nextY = this.y + this.dy;
                if (!this.checkWallCollision(nextX, this.y)) { this.x = nextX; }
                if (!this.checkWallCollision(this.x, nextY)) { this.y = nextY; }
            }
            checkWallCollision(x, y) {
                const buffer = this.size / 2;
                const corners = [ { x: x - buffer, y: y - buffer }, { x: x + buffer, y: y - buffer }, { x: x - buffer, y: y + buffer }, { x: x + buffer, y: y + buffer },];
                for (const corner of corners) {
                    const gridX = Math.floor(corner.x / GameState.tileSize); const gridY = Math.floor(corner.y / GameState.tileSize);
                    if (gridX < 0 || gridX >= Config.MAZE_LAYOUT[0].length || gridY < 0 || gridY >= Config.MAZE_LAYOUT.length) return true;
                    if (Config.MAZE_LAYOUT[gridY][gridX] === 1) return true;
                }
                return false;
            }
            changeDirection(dx, dy) { this.dx = dx * this.speed; this.dy = dy * this.speed; }
        }

        class Enemy {
             constructor(x, y, size, color, speed) {
                this.x = x; this.y = y; this.size = size; this.color = color; this.originalColor = color; this.speed = speed;
                this.isVulnerable = false; this.dx = 0; this.dy = 0; this.chooseNewDirection();
            }
            draw() {
                const style = getComputedStyle(document.documentElement);
                const VULNERABLE_GHOST_COLOR = style.getPropertyValue('--vulnerable-ghost-color').trim();
                UI.ctx.fillStyle = this.isVulnerable ? VULNERABLE_GHOST_COLOR : this.color; UI.ctx.beginPath(); const s = this.size;
                UI.ctx.arc(this.x, this.y, s / 2, Math.PI, 0); UI.ctx.lineTo(this.x + s / 2, this.y + s / 2); UI.ctx.lineTo(this.x + s / 2.5, this.y + s / 3); UI.ctx.lineTo(this.x + s / 5, this.y + s / 2); UI.ctx.lineTo(this.x, this.y + s / 3); UI.ctx.lineTo(this.x - s / 5, this.y + s / 2); UI.ctx.lineTo(this.x - s / 2.5, this.y + s / 3); UI.ctx.lineTo(this.x - s / 2, this.y + s / 2); UI.ctx.closePath(); UI.ctx.fill();
                UI.ctx.fillStyle = 'white'; UI.ctx.beginPath(); UI.ctx.arc(this.x - s/5, this.y - s/8, s/6, 0, Math.PI * 2); UI.ctx.arc(this.x + s/5, this.y - s/8, s/6, 0, Math.PI * 2); UI.ctx.fill();
                UI.ctx.fillStyle = 'black'; UI.ctx.beginPath(); UI.ctx.arc(this.x - s/5, this.y - s/8, s/12, 0, Math.PI * 2); UI.ctx.arc(this.x + s/5, this.y - s/8, s/12, 0, Math.PI * 2); UI.ctx.fill();
            }
            update() {
                const nextX = this.x + this.dx; const nextY = this.y + this.dy;
                if (this.checkWallCollision(nextX, nextY)) { this.chooseNewDirection(); } else { this.x = nextX; this.y = nextY; }
            }
            checkWallCollision(x, y) {
                 const gridX = Math.floor(x / GameState.tileSize); const gridY = Math.floor(y / GameState.tileSize); const buffer = this.size / 2;
                 if (x - buffer < 0 || x + buffer > UI.canvas.width || y - buffer < 0 || y + buffer > UI.canvas.height) return true;
                 return Config.MAZE_LAYOUT[gridY][gridX] === 1;
            }
            chooseNewDirection() {
                const directions = [ { dx: 0, dy: -this.speed }, { dx: 0, dy: this.speed }, { dx: -this.speed, dy: 0 }, { dx: this.speed, dy: 0 }, ];
                const newDirection = directions[Math.floor(Math.random() * directions.length)];
                this.dx = newDirection.dx; this.dy = newDirection.dy;
            }
            reset() {
                const pos = toPixels(Config.GHOST_START_POS.x, Config.GHOST_START_POS.y);
                this.x = pos.x;
                this.y = pos.y;
            }
        }

        class Answer {
            constructor(x, y, size, text) { this.x = x; this.y = y; this.size = size; this.text = text; }
            draw() {
                const star = '⭐';
                const starSize = this.size * 0.7;
                const textFontSize = this.size * 0.4;
                const textYOffset = starSize * 0.6;

                UI.ctx.font = `${starSize}px 'Press Start 2P'`;
                UI.ctx.textAlign = 'center';
                UI.ctx.textBaseline = 'middle';
                UI.ctx.fillText(star, this.x, this.y);

                UI.ctx.font = `${textFontSize}px 'Press Start 2P'`;
                const textWidth = UI.ctx.measureText(this.text).width;
                const padding = 4;
                const fullWidth = textWidth + padding * 2;
                
                let rectX = this.x - fullWidth / 2;
                
                if (rectX < 0) rectX = 0;
                if (rectX + fullWidth > UI.canvas.width) rectX = UI.canvas.width - fullWidth;
                
                const rectY = this.y + textYOffset - textFontSize / 2 - (padding / 2);

                UI.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                UI.ctx.fillRect(rectX, rectY, fullWidth, textFontSize + padding);

                UI.ctx.fillStyle = '#FFF';
                UI.ctx.textAlign = 'left';
                UI.ctx.textBaseline = 'middle';
                UI.ctx.fillText(this.text, rectX + padding, this.y + textYOffset);
            }
        }
        
        class PowerUp {
            constructor(x, y, size, type) { this.x = x; this.y = y; this.size = size; this.type = type; }
            draw() {
                UI.ctx.font = `${this.size}px 'Press Start 2P'`; UI.ctx.textAlign = 'center'; UI.ctx.textBaseline = 'middle';
                const emoji = this.type === 'heart' ? '❤️' : '🏆';
                UI.ctx.fillText(emoji, this.x, this.y);
            }
        }
        
        class CollectibleStar {
            constructor(x, y, size) { this.x = x; this.y = y; this.size = size; }
            draw() {
                UI.ctx.font = `${this.size * 0.7}px 'Press Start 2P'`; UI.ctx.textAlign = 'center'; UI.ctx.textBaseline = 'middle';
                UI.ctx.fillText('⭐', this.x, this.y);
            }
        }

        // =================================================================
        // MÓDULO PRINCIPAL DO JOGO (game.js)
        // =================================================================
        function generateQuestion() {
            const adverbTypes = Object.keys(Config.ADVERBS);
            const correctType = adverbTypes[Math.floor(Math.random() * adverbTypes.length)];
            const correctAdverb = Config.ADVERBS[correctType][Math.floor(Math.random() * Config.ADVERBS[correctType].length)];
            const options = [correctAdverb];
            const incorrectTypes = adverbTypes.filter(t => t !== correctType);
            while (options.length < 3) {
                const randomType = incorrectTypes[Math.floor(Math.random() * incorrectTypes.length)];
                const randomAdverb = Config.ADVERBS[randomType][Math.floor(Math.random() * Config.ADVERBS[randomType].length)];
                if (!options.includes(randomAdverb)) { options.push(randomAdverb); }
            }
            let questionTextType = correctType.toUpperCase();
            if (correctType === 'frequencia') { questionTextType = "FREQUÊNCIA (TEMPO)"; }
            return { question: `Qual é o advérbio de ${questionTextType}?`, options: options.sort(() => Math.random() - 0.5), correct: correctAdverb };
        }

        function toPixels(gridX, gridY) { return { x: gridX * GameState.tileSize + GameState.tileSize / 2, y: gridY * GameState.tileSize + GameState.tileSize / 2 }; }
        
        function resizeCanvas() {
            const container = document.getElementById('game-container-inner');
            const hudHeight = UI.hud.offsetHeight;
            const questionHeight = UI.questionEl.offsetHeight;
            const mobileControlsHeight = UI.mobileControls.offsetHeight;
            
            const availableHeight = window.innerHeight - hudHeight - questionHeight - mobileControlsHeight - 20;
            const availableWidth = container.clientWidth;

            const aspectWidth = Config.MAZE_LAYOUT[0].length; const aspectHeight = Config.MAZE_LAYOUT.length;
            
            let newWidth = availableWidth;
            let newHeight = newWidth * (aspectHeight / aspectWidth);

            if (newHeight > availableHeight) {
                newHeight = availableHeight;
                newWidth = newHeight * (aspectWidth / aspectHeight);
            }
            
            UI.canvas.width = newWidth; UI.canvas.height = newHeight; GameState.tileSize = UI.canvas.width / Config.MAZE_LAYOUT[0].length;
            if (GameState.player) setupLevel(false);
        }
        
        function drawMaze() {
            const WALL_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--wall-color').trim();
            for (let y = 0; y < Config.MAZE_LAYOUT.length; y++) {
                for (let x = 0; x < Config.MAZE_LAYOUT[y].length; x++) {
                    if (Config.MAZE_LAYOUT[y][x] === 1) { UI.ctx.fillStyle = WALL_COLOR; UI.ctx.fillRect(x * GameState.tileSize, y * GameState.tileSize, GameState.tileSize, GameState.tileSize); }
                }
            }
        }
        
        function getEmptyLocation(occupied = []) {
            let x, y;
            let isOccupied;
            do {
                x = Math.floor(Math.random() * Config.MAZE_LAYOUT[0].length);
                y = Math.floor(Math.random() * Config.MAZE_LAYOUT.length);
                isOccupied = occupied.some(p => p.x === x && p.y === y) || Config.MAZE_LAYOUT[y][x] === 1;
            } while (isOccupied);
            return { x, y };
        }

        function updateHUD() {
            UI.scoreEl.textContent = `Pontos: ${GameState.score}`; 
            UI.levelEl.textContent = `Nível: ${GameState.level}`; 
            UI.livesEl.innerHTML = 'Vidas: ' + '❤️'.repeat(GameState.lives);
        }

        function addExtraGhost() {
            if (!GameState.gameRunning) return;

            const style = getComputedStyle(document.documentElement);
            const GHOST_COLORS = [
                style.getPropertyValue('--ghost-color-1').trim(),
                style.getPropertyValue('--ghost-color-2').trim(),
                style.getPropertyValue('--ghost-color-3').trim(),
                style.getPropertyValue('--ghost-color-4').trim()
            ];
            
            const pixelPos = toPixels(Config.GHOST_START_POS.x, Config.GHOST_START_POS.y);
            let speed = 1 + (GameState.level * 0.1);
            if (GameState.level >= 10) {
                speed += (GameState.level - 9) * 0.05;
            }

            const newGhost = new Enemy(
                pixelPos.x, 
                pixelPos.y, 
                GameState.tileSize * 0.8, 
                GHOST_COLORS[GameState.enemies.length % GHOST_COLORS.length], 
                speed
            );

            if (GameState.isPoweredUp) {
                newGhost.isVulnerable = true;
            }

            GameState.enemies.push(newGhost);
        }

        function setupLevel(newQuestion = true) {
            GameState.gameRunning = true;
            if (newQuestion) { GameState.currentQuestion = generateQuestion(); }
            
            UI.questionEl.textContent = GameState.currentQuestion.question;
            updateHUD();
            
            let occupiedGrids = [Config.PLAYER_START_POS, Config.GHOST_START_POS];

            const playerPos = toPixels(Config.PLAYER_START_POS.x, Config.PLAYER_START_POS.y);
            GameState.player = new Player(playerPos.x, playerPos.y, GameState.tileSize * 0.55, 2);

            GameState.answers = [];
            GameState.currentQuestion.options.forEach((optionText) => {
                const gridPos = getEmptyLocation(occupiedGrids);
                occupiedGrids.push(gridPos);
                if(gridPos.x > 0) occupiedGrids.push({x: gridPos.x - 1, y: gridPos.y});
                if(gridPos.x < Config.MAZE_LAYOUT[0].length - 1) occupiedGrids.push({x: gridPos.x + 1, y: gridPos.y});
                if(gridPos.y > 0) occupiedGrids.push({x: gridPos.x, y: gridPos.y - 1});
                if(gridPos.y < Config.MAZE_LAYOUT.length - 1) occupiedGrids.push({x: gridPos.x, y: gridPos.y + 1});

                const pixelPos = toPixels(gridPos.x, gridPos.y);
                const answer = new Answer(pixelPos.x, pixelPos.y, GameState.tileSize, optionText);
                answer.isCorrect = (optionText === GameState.currentQuestion.correct);
                GameState.answers.push(answer);
            });
            
            const style = getComputedStyle(document.documentElement);
            const GHOST_COLORS = [
                style.getPropertyValue('--ghost-color-1').trim(),
                style.getPropertyValue('--ghost-color-2').trim(),
                style.getPropertyValue('--ghost-color-3').trim(),
                style.getPropertyValue('--ghost-color-4').trim()
            ];

            GameState.enemies = [];
            for (let i = 0; i < GameState.level; i++) {
                const pixelPos = toPixels(Config.GHOST_START_POS.x, Config.GHOST_START_POS.y);
                let speed = 1 + (GameState.level * 0.1);
                if (GameState.level >= 10) {
                    speed += (GameState.level - 9) * 0.05;
                }
                GameState.enemies.push(new Enemy(pixelPos.x, pixelPos.y, GameState.tileSize * 0.8, GHOST_COLORS[i % GHOST_COLORS.length], speed));
            }
            
            GameState.powerUp = null;
            if (GameState.level > 1) {
                if (GameState.level % 2 === 0) {
                    if (Math.random() < 0.75) {
                        const gridPos = getEmptyLocation(occupiedGrids);
                        occupiedGrids.push(gridPos);
                        const pixelPos = toPixels(gridPos.x, gridPos.y);
                        GameState.powerUp = new PowerUp(pixelPos.x, pixelPos.y, GameState.tileSize, 'heart');
                    }
                } else {
                    if (Math.random() < 0.6) {
                        const gridPos = getEmptyLocation(occupiedGrids);
                        occupiedGrids.push(gridPos);
                        const pixelPos = toPixels(gridPos.x, gridPos.y);
                        GameState.powerUp = new PowerUp(pixelPos.x, pixelPos.y, GameState.tileSize, 'trophy');
                    }
                }
            }
            
            GameState.collectibleStars = [];
            const starCount = 1 + Math.floor(GameState.level / 3);
            for(let i = 0; i < starCount; i++) {
                const gridPos = getEmptyLocation(occupiedGrids);
                occupiedGrids.push(gridPos);
                const pixelPos = toPixels(gridPos.x, gridPos.y);
                GameState.collectibleStars.push(new CollectibleStar(pixelPos.x, pixelPos.y, GameState.tileSize));
            }

            clearInterval(GameState.levelTimer);
            GameState.levelTimer = setInterval(addExtraGhost, 30000);
        }
        
        function handleLifeLost() {
            GameState.lives--; 
            updateHUD();
            if (GameState.lives <= 0) { endGame(false); return; }
            
            const playerPos = toPixels(Config.PLAYER_START_POS.x, Config.PLAYER_START_POS.y);
            GameState.player.x = playerPos.x; GameState.player.y = playerPos.y;
            GameState.enemies.forEach(enemy => enemy.reset());
        }

        function checkCollisions() {
            GameState.answers.forEach((answer) => {
                const dist = Math.hypot(GameState.player.x - answer.x, GameState.player.y - answer.y);
                const starRadius = GameState.tileSize * 0.5;
                if (dist < GameState.player.size / 2 + starRadius) {
                    if (answer.isCorrect) { GameState.score += 3; GameState.level++;
                    } else { GameState.score = Math.max(0, GameState.score - 1); }
                    setupLevel(true); return;
                }
            });
            
            for (let i = GameState.enemies.length - 1; i >= 0; i--) {
                const enemy = GameState.enemies[i];
                const dist = Math.hypot(GameState.player.x - enemy.x, GameState.player.y - enemy.y);
                if (dist < GameState.player.size / 2 + enemy.size / 2) {
                    if (GameState.isPoweredUp) {
                        GameState.score += 5;
                        GameState.enemies.splice(i, 1);
                    } else {
                        handleLifeLost();
                        break; 
                    }
                }
            }

            if (GameState.powerUp) {
                const dist = Math.hypot(GameState.player.x - GameState.powerUp.x, GameState.player.y - GameState.powerUp.y);
                if (dist < GameState.player.size / 2 + GameState.powerUp.size / 2) {
                    if (GameState.powerUp.type === 'heart') {
                        GameState.lives++; updateHUD();
                    } else if (GameState.powerUp.type === 'trophy') {
                        GameState.isPoweredUp = true;
                        GameState.enemies.forEach(e => e.isVulnerable = true);
                        clearTimeout(GameState.powerUpTimer);
                        GameState.powerUpTimer = setTimeout(() => {
                            GameState.isPoweredUp = false;
                            GameState.enemies.forEach(e => e.isVulnerable = false);
                        }, 30000);
                    }
                    GameState.powerUp = null;
                }
            }

            for (let i = GameState.collectibleStars.length - 1; i >= 0; i--) {
                const star = GameState.collectibleStars[i];
                const dist = Math.hypot(GameState.player.x - star.x, GameState.player.y - star.y);
                if (dist < GameState.player.size / 2 + star.size / 2) {
                    GameState.score += 3;
                    updateHUD();
                    GameState.collectibleStars.splice(i, 1);
                }
            }
        }
        
        function endGame(isWinner) {
            GameState.gameRunning = false;
            clearInterval(GameState.levelTimer);
            const gameEndTime = new Date();
            const gameDurationSeconds = Math.round((gameEndTime - GameState.gameStartTime) / 1000);

            UI.gameContainer.style.display = 'none';
            UI.endScreen.style.display = 'flex';
            
            UI.endTitleEl.textContent = isWinner ? `Parabéns, ${GameState.playerName}!` : 'Fim de Jogo!';
            UI.finalScoreEl.textContent = `Sua Pontuação: ${GameState.score}`;
            UI.gameDurationEl.textContent = `Tempo de Jogo: ${gameDurationSeconds} segundos`;
            UI.gameDateTimeEl.textContent = `Realizado em: ${gameEndTime.toLocaleDateString('pt-BR')} às ${gameEndTime.toLocaleTimeString('pt-BR')}`;
            
            const finalGameData = {
                date: gameEndTime.toLocaleString('pt-BR'),
                playerClass: document.getElementById('playerClass').value,
                playerName: GameState.playerName,
                score: GameState.score,
                time: gameDurationSeconds
            };

            sendDataToSheet(finalGameData);
            saveScoreToLocal(gameEndTime);
            displayLocalScores(UI.leaderboardListEl, 5);
        }
        
        async function sendDataToSheet(data) {
            if (!Config.SCRIPT_URL) {
                console.log("URL do Apps Script não configurada. Dados não serão enviados.");
                return;
            }
            try {
                await fetch(Config.SCRIPT_URL, {
                    method: 'POST', mode: 'no-cors', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data)
                });
            } catch (error) { console.error("Erro ao enviar dados para a planilha:", error); }
        }

        function saveScoreToLocal(date) {
            const scoreData = { name: GameState.playerName, score: GameState.score, date: date.toISOString() };
            let highScores = JSON.parse(localStorage.getItem('adverbManHighScores')) || [];
            highScores.push(scoreData);
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 20);
            localStorage.setItem('adverbManHighScores', JSON.stringify(highScores));
        }

        function displayLocalScores(listElement, limit) {
            let highScores = JSON.parse(localStorage.getItem('adverbManHighScores')) || [];
            listElement.innerHTML = '';
            if (highScores.length === 0) {
                listElement.innerHTML = '<li>Seja o primeiro a pontuar!</li>';
            } else {
                highScores.slice(0, limit).forEach(s => {
                    const li = document.createElement('li');
                    const scoreDate = new Date(s.date);
                    li.innerHTML = `<span class="score-name">${s.name}</span> <span>${s.score} pts (${scoreDate.toLocaleDateString('pt-BR')})</span>`;
                    listElement.appendChild(li);
                });
            }
        }

        function gameLoop() {
            if (!GameState.gameRunning) return;
            const PATH_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--path-color').trim();
            UI.ctx.fillStyle = PATH_COLOR; UI.ctx.fillRect(0, 0, UI.canvas.width, UI.canvas.height);
            drawMaze();
            if (GameState.powerUp) { GameState.powerUp.draw(); }
            GameState.collectibleStars.forEach(star => star.draw());
            GameState.answers.forEach(answer => answer.draw());
            GameState.player.update(); GameState.player.draw();
            GameState.enemies.forEach(enemy => { enemy.update(); enemy.draw(); });
            checkCollisions();
            requestAnimationFrame(gameLoop);
        }

        // --- CONTROLS ---
        function handleKeyDown(e) {
            if (!GameState.player || !e || !e.key) return;
            if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') GameState.player.changeDirection(0, -1);
            else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') GameState.player.changeDirection(0, 1);
            else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') GameState.player.changeDirection(-1, 0);
            else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') GameState.player.changeDirection(1, 0);
        }
        function handleKeyUp(e) {
             if (!GameState.player || !e || !e.key) return;
             if (['arrowup', 'w', 'arrowdown', 's', 'arrowleft', 'a', 'arrowright', 'd'].includes(e.key.toLowerCase())) { GameState.player.changeDirection(0, 0); }
        }
        function setupMobileControls() {
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (isTouchDevice) {
                UI.mobileControls.style.display = 'grid';
                const buttons = UI.mobileControls.querySelectorAll('button');
                buttons.forEach(button => {
                    const press = (e) => {
                        e.preventDefault(); const direction = button.className;
                        if (direction === 'up') GameState.player.changeDirection(0, -1); if (direction === 'down') GameState.player.changeDirection(0, 1);
                        if (direction === 'left') GameState.player.changeDirection(-1, 0); if (direction === 'right') GameState.player.changeDirection(1, 0);
                    };
                    const release = (e) => { e.preventDefault(); GameState.player.changeDirection(0, 0); };
                    button.addEventListener('touchstart', press); button.addEventListener('mousedown', press);
                    button.addEventListener('touchend', release); button.addEventListener('mouseup', release);
                    button.addEventListener('mouseleave', release);
                });
            }
        }

        // --- INITIALIZATION & SCREEN MANAGEMENT ---
        function startGame() {
            GameState.playerName = UI.playerNameInput.value || "Ana";
            GameState.gameStartTime = new Date();
            UI.startScreen.style.display = 'none';
            UI.gameContainer.style.display = 'flex';
            UI.endScreen.style.display = 'none';
            UI.rankingScreen.style.display = 'none';
            resizeCanvas();
            setupLevel(true);
            setupMobileControls();
            gameLoop();
        }

        async function showRanking() {
            UI.startScreen.style.display = 'none';
            UI.rankingScreen.style.display = 'flex';
            UI.rankingListEl.innerHTML = '<li>Carregando ranking...</li>';

            if (!Config.SCRIPT_URL) {
                UI.rankingListEl.innerHTML = '<li>Ranking online indisponível.</li>';
                return;
            }

            try {
                const response = await fetch(Config.SCRIPT_URL);
                const result = await response.json();

                if (result.status === "success") {
                    UI.rankingListEl.innerHTML = '';
                    if (result.data.length === 0) {
                        UI.rankingListEl.innerHTML = '<li>Nenhuma pontuação registrada ainda.</li>';
                    } else {
                        result.data.forEach(s => {
                            const li = document.createElement('li');
                            li.innerHTML = `<span class="score-name">${s.Nome}</span> <span>${s.Pontuação} pts</span>`;
                            UI.rankingListEl.appendChild(li);
                        });
                    }
                } else {
                    UI.rankingListEl.innerHTML = `<li>Erro ao carregar ranking.</li>`;
                }
            } catch (error) {
                console.error("Erro ao buscar ranking:", error);
                UI.rankingListEl.innerHTML = '<li>Não foi possível conectar ao ranking.</li>';
            }
        }

        function showStartScreen() {
            UI.startScreen.style.display = 'flex';
            UI.rankingScreen.style.display = 'none';
        }
        
        function resetGame() { window.location.reload(); }

        UI.startButton.addEventListener('click', startGame);
        UI.restartButton.addEventListener('click', resetGame);
        UI.rankingButton.addEventListener('click', showRanking);
        UI.backToStartButton.addEventListener('click', showStartScreen);

        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        window.addEventListener('resize', () => { resizeCanvas(); });
      });
    </script>
</body>
</html>
