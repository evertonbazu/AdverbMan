<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Adverb-Man: O Labirinto dos Advérbios</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #000020;
            --primary-color: #FFFF00;
            --wall-color: #0000FF;
            --path-color: #000;
            --text-color: #FFFFFF;
            --correct-color: #00FF00;
            --incorrect-color: #FF0000;
            --ghost-color-1: #FF00FF;
            --ghost-color-2: #00FFFF;
            --ghost-color-3: #FFB8FF;
            --ghost-color-4: #FF5733;
            --vulnerable-ghost-color: #2196F3;
        }

        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 1rem;
            background-color: #111;
            border: 3px solid var(--wall-color);
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
        }
        
        #start-screen {
            display: flex;
        }
        #game-container, #end-screen, #ranking-screen {
            display: none;
        }


        #start-screen h1, #end-screen h1, #ranking-screen h1 {
            font-size: clamp(1.2rem, 5vw, 2.5rem);
            color: var(--primary-color);
            margin-bottom: 1.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
            width: 100%;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: clamp(0.8rem, 3vw, 1rem);
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.5rem;
            font-family: 'Press Start 2P', cursive;
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 2px solid var(--wall-color);
            border-radius: 5px;
            font-size: clamp(0.8rem, 3vw, 1rem);
        }

        .action-button {
            padding: 0.75rem 1.5rem;
            font-family: 'Press Start 2P', cursive;
            background-color: var(--primary-color);
            color: var(--bg-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: clamp(1rem, 4vw, 1.2rem);
            margin-top: 1rem;
        }
        
        #game-container {
            flex-direction: column;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: space-between;
        }
        
        #game-container-inner {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 0.3rem 0.5rem;
            font-size: clamp(0.6rem, 2.5vw, 1rem);
            background-color: #111;
            border-radius: 10px 10px 0 0;
            border: 2px solid var(--wall-color);
            border-bottom: none;
            box-sizing: border-box;
            flex-wrap: wrap;
        }

        #hud span {
            margin: 2px 5px;
        }

        #lives {
            color: #FF69B4;
        }

        #question-display {
            text-align: center;
            width: 100%;
            padding: 0.5rem;
            font-size: clamp(0.6rem, 2.5vw, 0.9rem);
            background-color: #111;
            border-top: none;
            border-bottom: none;
            box-sizing: border-box;
            color: var(--primary-color);
        }

        canvas {
            background-color: var(--path-color);
            border: 2px solid var(--wall-color);
            width: 100%;
            height: auto;
            aspect-ratio: 20 / 15;
            border-radius: 0 0 10px 10px;
            flex-grow: 1;
            min-height: 0;
        }

        #mobile-controls {
            display: none;
            width: 100%;
            padding: 1rem 0;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
            max-width: 200px;
            justify-items: center;
        }
        
        #mobile-controls button {
            background-color: var(--wall-color);
            color: var(--text-color);
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            font-size: clamp(1.5rem, 5vw, 2rem);
            width: clamp(50px, 15vw, 70px);
            height: clamp(50px, 15vw, 70px);
            font-family: 'Press Start 2P', cursive;
            user-select: none;
        }
        
        #mobile-controls .up { grid-column: 2; grid-row: 1; }
        #mobile-controls .left { grid-column: 1; grid-row: 2; }
        #mobile-controls .right { grid-column: 3; grid-row: 2; }
        #mobile-controls .down { grid-column: 2; grid-row: 2; }
        
        #end-screen h2, #ranking-screen h2 {
            margin-bottom: 1rem;
        }

        #leaderboard, #ranking-board {
            width: 100%;
            margin-top: 1.5rem;
            font-size: clamp(0.7rem, 2.5vw, 0.9rem);
        }
        
        #leaderboard h3, #ranking-board h3 {
             color: var(--primary-color);
             margin-bottom: 1rem;
        }

        #leaderboard ol, #ranking-board ol {
            list-style: none;
            padding: 0;
            text-align: left;
        }
        
        #leaderboard li, #ranking-board li {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            border-radius: 5px;
        }

        #leaderboard li:nth-child(odd), #ranking-board li:nth-child(odd) {
            background-color: #222;
        }
        
        .score-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 50%;
        }

    </style>
</head>
<body>

    <div id="start-screen" class="screen">
        <h1>Adverb-Man</h1>
        <div class="form-group">
            <label for="playerName">Nome:</label>
            <input type="text" id="playerName" placeholder="Digite seu nome">
        </div>
        <div class="form-group">
            <label for="playerClass">Turma:</label>
            <select id="playerClass">
                <option value="5A">5º Ano A</option>
                <option value="5B">5º Ano B</option>
            </select>
        </div>
        <button id="start-button" class="action-button">Começar a Jogar</button>
        <button id="ranking-button" class="action-button">Ver Ranking</button>
    </div>

    <div id="game-container">
      <div id="game-container-inner">
        <div id="hud">
            <span id="score">Pontos: 0</span>
            <span id="level">Nível: 1</span>
            <span id="lives">Vidas: ❤️❤️❤️❤️❤️</span>
        </div>
        <div id="question-display">Carregando pergunta...</div>
        <canvas id="gameCanvas"></canvas>
      </div>
      <div id="mobile-controls">
        <button class="up">▲</button>
        <button class="left">◄</button>
        <button class="down">▼</button>
        <button class="right">►</button>
      </div>
    </div>
    
    <div id="end-screen" class="screen">
        <h1 id="end-title">Fim de Jogo!</h1>
        <h2 id="final-score">Sua Pontuação: 0</h2>
        <p id="game-duration"></p>
        <p id="game-date-time"></p>
        <div id="leaderboard">
            <h3>Melhores 5 Pontuações</h3>
            <ol id="leaderboard-list"></ol>
        </div>
        <button id="restart-button" class="action-button">Jogar Novamente</button>
    </div>

    <div id="ranking-screen" class="screen">
        <h1>Melhores 20 Pontuações</h1>
        <div id="ranking-board">
            <ol id="ranking-list"></ol>
        </div>
        <button id="back-to-start-button" class="action-button">Voltar</button>
    </div>

    <script>
        // --- SETUP ---
        const startScreen = document.getElementById('start-screen');
        const gameContainer = document.getElementById('game-container');
        const endScreen = document.getElementById('end-screen');
        const rankingScreen = document.getElementById('ranking-screen');

        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const rankingButton = document.getElementById('ranking-button');
        const backToStartButton = document.getElementById('back-to-start-button');
        
        const playerNameInput = document.getElementById('playerName');

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const livesEl = document.getElementById('lives');
        const questionEl = document.getElementById('question-display');
        const mobileControls = document.getElementById('mobile-controls');
        
        const finalScoreEl = document.getElementById('final-score');
        const gameDurationEl = document.getElementById('game-duration');
        const gameDateTimeEl = document.getElementById('game-date-time');
        const leaderboardListEl = document.getElementById('leaderboard-list');
        const rankingListEl = document.getElementById('ranking-list');
        const endTitleEl = document.getElementById('end-title');

        // --- GOOGLE SHEETS INTEGRATION ---
        const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxMLunxIV6qQD4Fm90TLQTE7Fj0sbU0FWlVkhDN3_irAWufbHiMarfTIYuTzgwl3KnZfg/exec";

        // --- COLOR VARIABLES ---
        const style = getComputedStyle(document.documentElement);
        const WALL_COLOR = style.getPropertyValue('--wall-color').trim();
        const PATH_COLOR = style.getPropertyValue('--path-color').trim();
        const CORRECT_COLOR = style.getPropertyValue('--correct-color').trim();
        const INCORRECT_COLOR = style.getPropertyValue('--incorrect-color').trim();
        const GHOST_COLOR_1 = style.getPropertyValue('--ghost-color-1').trim();
        const GHOST_COLOR_2 = style.getPropertyValue('--ghost-color-2').trim();
        const GHOST_COLOR_3 = style.getPropertyValue('--ghost-color-3').trim();
        const GHOST_COLOR_4 = style.getPropertyValue('--ghost-color-4').trim();
        const VULNERABLE_GHOST_COLOR = style.getPropertyValue('--vulnerable-ghost-color').trim();

        let score = 0;
        let level = 1;
        let lives = 5;
        let player, enemies, answers, currentQuestion, powerUp;
        let gameRunning = true;
        let tileSize;
        let playerName = "Ana";
        let isPoweredUp = false;
        let powerUpTimer;
        let gameStartTime;

        // --- MAZE LAYOUT ---
        const mazeLayout = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1],
            [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1],
            [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1],
            [1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1],
            [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];
        const PLAYER_START_POS = { x: 1, y: 1 };
        const GHOST_START_POS = { x: 18, y: 1 };

        // --- GAME DATA ---
        const adverbs = {
            afirmacao: ["sim", "certamente", "realmente", "definitivamente", "verdadeiramente", "efetivamente", "claramente", "seguramente", "decerto"],
            duvida: ["talvez", "quiçá", "possivelmente", "provavelmente", "eventualmente", "acaso"],
            negacao: ["não", "nunca", "jamais", "tampouco"],
            tempo: ["hoje", "ontem", "amanhã", "agora", "cedo", "tarde", "logo", "imediatamente", "brevemente", "recentemente", "outrora", "anteriormente", "posteriormente", "ultimamente"],
            frequencia: ["sempre", "frequentemente", "raramente", "ocasionalmente", "diariamente", "periodicamente", "constantemente", "esporadicamente"],
            modo: ["bem", "mal", "depressa", "devagar", "rapidamente", "lentamente", "cuidadosamente", "calmamente", "facilmente", "suavemente"],
            lugar: ["aqui", "ali", "lá", "cá", "perto", "longe", "acima", "abaixo", "dentro", "fora", "adiante", "atrás", "acolá"],
            intensidade: ["muito", "pouco", "bastante", "demais", "mais", "menos", "extremamente", "totalmente", "completamente", "absolutamente"]
        };
        const adverbTypes = Object.keys(adverbs);

        function generateQuestion() {
            const correctType = adverbTypes[Math.floor(Math.random() * adverbTypes.length)];
            const correctAdverb = adverbs[correctType][Math.floor(Math.random() * adverbs[correctType].length)];
            const options = [correctAdverb];
            const incorrectTypes = adverbTypes.filter(t => t !== correctType);
            while (options.length < 3) {
                const randomType = incorrectTypes[Math.floor(Math.random() * incorrectTypes.length)];
                const randomAdverb = adverbs[randomType][Math.floor(Math.random() * adverbs[randomType].length)];
                if (!options.includes(randomAdverb)) { options.push(randomAdverb); }
            }
            let questionTextType = correctType.toUpperCase();
            if (correctType === 'frequencia') { questionTextType = "FREQUÊNCIA (TEMPO)"; }
            return { question: `Qual é o advérbio de ${questionTextType}?`, options: options.sort(() => Math.random() - 0.5), correct: correctAdverb };
        }

        // --- CLASSES ---
        class Player {
            constructor(x, y, size, speed) { this.x = x; this.y = y; this.size = size; this.speed = speed; this.dx = 0; this.dy = 0; this.visible = true; }
            draw() {
                if (!this.visible) return;
                const s = this.size; ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = '#A52A2A'; ctx.beginPath(); ctx.arc(0, -s/4, s/2.5, 0, Math.PI * 2); ctx.fill(); ctx.fillRect(-s/2.5, -s/4, s/1.25, s/4);
                ctx.fillStyle = '#FFDAB9'; ctx.beginPath(); ctx.arc(0, 0, s / 3, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(-s / 10, -s / 20, s / 20, 0, Math.PI * 2); ctx.arc(s / 10, -s / 20, s / 20, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#87CEEB'; ctx.beginPath(); ctx.moveTo(-s/4, s/4); ctx.lineTo(s/4, s/4); ctx.lineTo(s/3, s/2); ctx.lineTo(-s/3, s/2); ctx.closePath(); ctx.fill();
                ctx.restore();
            }
            update() {
                const nextX = this.x + this.dx; const nextY = this.y + this.dy;
                if (!this.checkWallCollision(nextX, this.y)) { this.x = nextX; }
                if (!this.checkWallCollision(this.x, nextY)) { this.y = nextY; }
            }
            checkWallCollision(x, y) {
                const buffer = this.size / 2;
                const corners = [ { x: x - buffer, y: y - buffer }, { x: x + buffer, y: y - buffer }, { x: x - buffer, y: y + buffer }, { x: x + buffer, y: y + buffer },];
                for (const corner of corners) {
                    const gridX = Math.floor(corner.x / tileSize); const gridY = Math.floor(corner.y / tileSize);
                    if (gridX < 0 || gridX >= mazeLayout[0].length || gridY < 0 || gridY >= mazeLayout.length) return true;
                    if (mazeLayout[gridY][gridX] === 1) return true;
                }
                return false;
            }
            changeDirection(dx, dy) { this.dx = dx * this.speed; this.dy = dy * this.speed; }
        }

        class Enemy {
             constructor(x, y, size, color, speed) {
                this.x = x; this.y = y; this.size = size; this.color = color; this.originalColor = color; this.speed = speed;
                this.isVulnerable = false; this.dx = 0; this.dy = 0; this.chooseNewDirection();
            }
            draw() {
                ctx.fillStyle = this.isVulnerable ? VULNERABLE_GHOST_COLOR : this.color; ctx.beginPath(); const s = this.size;
                ctx.arc(this.x, this.y, s / 2, Math.PI, 0); ctx.lineTo(this.x + s / 2, this.y + s / 2); ctx.lineTo(this.x + s / 2.5, this.y + s / 3); ctx.lineTo(this.x + s / 5, this.y + s / 2); ctx.lineTo(this.x, this.y + s / 3); ctx.lineTo(this.x - s / 5, this.y + s / 2); ctx.lineTo(this.x - s / 2.5, this.y + s / 3); ctx.lineTo(this.x - s / 2, this.y + s / 2); ctx.closePath(); ctx.fill();
                ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(this.x - s/5, this.y - s/8, s/6, 0, Math.PI * 2); ctx.arc(this.x + s/5, this.y - s/8, s/6, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(this.x - s/5, this.y - s/8, s/12, 0, Math.PI * 2); ctx.arc(this.x + s/5, this.y - s/8, s/12, 0, Math.PI * 2); ctx.fill();
            }
            update() {
                const nextX = this.x + this.dx; const nextY = this.y + this.dy;
                if (this.checkWallCollision(nextX, nextY)) { this.chooseNewDirection(); } else { this.x = nextX; this.y = nextY; }
            }
            checkWallCollision(x, y) {
                 const gridX = Math.floor(x / tileSize); const gridY = Math.floor(y / tileSize); const buffer = this.size / 2;
                 if (x - buffer < 0 || x + buffer > canvas.width || y - buffer < 0 || y + buffer > canvas.height) return true;
                 return mazeLayout[gridY][gridX] === 1;
            }
            chooseNewDirection() {
                const directions = [ { dx: 0, dy: -this.speed }, { dx: 0, dy: this.speed }, { dx: -this.speed, dy: 0 }, { dx: this.speed, dy: 0 }, ];
                const newDirection = directions[Math.floor(Math.random() * directions.length)];
                this.dx = newDirection.dx; this.dy = newDirection.dy;
            }
            reset() {
                const pos = toPixels(GHOST_START_POS.x, GHOST_START_POS.y);
                this.x = pos.x;
                this.y = pos.y;
            }
        }

        class Answer {
            constructor(x, y, size, text) { this.x = x; this.y = y; this.size = size; this.text = text; }
            draw() {
                const star = '⭐';
                const starSize = this.size * 0.7;
                const textFontSize = this.size * 0.4;
                const textYOffset = starSize * 0.6;

                ctx.font = `${starSize}px 'Press Start 2P'`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(star, this.x, this.y);

                ctx.font = `${textFontSize}px 'Press Start 2P'`;
                const textWidth = ctx.measureText(this.text).width;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(this.x - textWidth / 2 - 4, this.y + textYOffset - textFontSize / 2 - 2, textWidth + 8, textFontSize + 4);

                ctx.fillStyle = '#FFF';
                ctx.fillText(this.text, this.x, this.y + textYOffset);
            }
        }
        
        class PowerUp {
            constructor(x, y, size, type) { this.x = x; this.y = y; this.size = size; this.type = type; }
            draw() {
                ctx.font = `${this.size}px 'Press Start 2P'`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const emoji = this.type === 'heart' ? '❤️' : '🏆';
                ctx.fillText(emoji, this.x, this.y);
            }
        }

        // --- GAME FUNCTIONS ---
        function toPixels(gridX, gridY) { return { x: gridX * tileSize + tileSize / 2, y: gridY * tileSize + tileSize / 2 }; }
        function resizeCanvas() {
            const container = document.getElementById('game-container-inner');
            const hudHeight = document.getElementById('hud').offsetHeight;
            const questionHeight = document.getElementById('question-display').offsetHeight;
            const mobileControlsHeight = document.getElementById('mobile-controls').offsetHeight;
            
            const availableHeight = window.innerHeight - hudHeight - questionHeight - mobileControlsHeight - 20;
            const availableWidth = container.clientWidth;

            const aspectWidth = mazeLayout[0].length; const aspectHeight = mazeLayout.length;
            
            let newWidth = availableWidth;
            let newHeight = newWidth * (aspectHeight / aspectWidth);

            if (newHeight > availableHeight) {
                newHeight = availableHeight;
                newWidth = newHeight * (aspectWidth / aspectHeight);
            }
            
            canvas.width = newWidth; canvas.height = newHeight; tileSize = canvas.width / mazeLayout[0].length;
            if (player) setupLevel(false);
        }
        
        function drawMaze() {
            for (let y = 0; y < mazeLayout.length; y++) {
                for (let x = 0; x < mazeLayout[y].length; x++) {
                    if (mazeLayout[y][x] === 1) { ctx.fillStyle = WALL_COLOR; ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize); }
                }
            }
        }
        
        function getEmptyLocation(occupied = []) {
            let x, y;
            let isOccupied;
            do {
                x = Math.floor(Math.random() * mazeLayout[0].length);
                y = Math.floor(Math.random() * mazeLayout.length);
                isOccupied = occupied.some(p => p.x === x && p.y === y) || mazeLayout[y][x] === 1;
            } while (isOccupied);
            return { x, y };
        }

        function updateHUD() {
            scoreEl.textContent = `Pontos: ${score}`; levelEl.textContent = `Nível: ${level}`; livesEl.innerHTML = 'Vidas: ' + '❤️'.repeat(lives);
        }

        function setupLevel(newQuestion = true) {
            gameRunning = true;
            if (newQuestion) { currentQuestion = generateQuestion(); }
            
            questionEl.textContent = currentQuestion.question;
            updateHUD();
            
            let occupiedGrids = [PLAYER_START_POS, GHOST_START_POS];

            const playerPos = toPixels(PLAYER_START_POS.x, PLAYER_START_POS.y);
            player = new Player(playerPos.x, playerPos.y, tileSize * 0.7, 2);

            answers = [];
            currentQuestion.options.forEach((optionText) => {
                const gridPos = getEmptyLocation(occupiedGrids);
                occupiedGrids.push(gridPos);
                if(gridPos.x > 0) occupiedGrids.push({x: gridPos.x - 1, y: gridPos.y});
                if(gridPos.x < mazeLayout[0].length - 1) occupiedGrids.push({x: gridPos.x + 1, y: gridPos.y});

                const pixelPos = toPixels(gridPos.x, gridPos.y);
                const answer = new Answer(pixelPos.x, pixelPos.y, tileSize, optionText);
                answer.isCorrect = (optionText === currentQuestion.correct);
                answers.push(answer);
            });
            
            enemies = [];
            const enemyColors = [GHOST_COLOR_1, GHOST_COLOR_2, GHOST_COLOR_3, GHOST_COLOR_4];
            for (let i = 0; i < level; i++) {
                const pixelPos = toPixels(GHOST_START_POS.x, GHOST_START_POS.y);
                const speed = 1 + (level * 0.1);
                enemies.push(new Enemy(pixelPos.x, pixelPos.y, tileSize * 0.8, enemyColors[i % enemyColors.length], speed));
            }
            
            powerUp = null;
            if (level > 1) {
                if (level % 2 === 0) {
                    if (Math.random() < 0.75) { // 75% chance for heart on even levels
                        const gridPos = getEmptyLocation(occupiedGrids);
                        occupiedGrids.push(gridPos);
                        const pixelPos = toPixels(gridPos.x, gridPos.y);
                        powerUp = new PowerUp(pixelPos.x, pixelPos.y, tileSize, 'heart');
                    }
                } else {
                    if (Math.random() < 0.6) { // 60% chance for trophy on odd levels
                        const gridPos = getEmptyLocation(occupiedGrids);
                        occupiedGrids.push(gridPos);
                        const pixelPos = toPixels(gridPos.x, gridPos.y);
                        powerUp = new PowerUp(pixelPos.x, pixelPos.y, tileSize, 'trophy');
                    }
                }
            }
        }
        
        function handleLifeLost() {
            lives--; updateHUD();
            if (lives <= 0) { endGame(false); return; }
            
            const playerPos = toPixels(PLAYER_START_POS.x, PLAYER_START_POS.y);
            player.x = playerPos.x; player.y = playerPos.y;
            enemies.forEach(enemy => enemy.reset());
        }

        function checkCollisions() {
            answers.forEach((answer) => {
                const dist = Math.hypot(player.x - answer.x, player.y - answer.y);
                const starRadius = tileSize * 0.5;
                if (dist < player.size / 2 + starRadius) {
                    if (answer.isCorrect) { score += 3; level++;
                    } else { score = Math.max(0, score - 1); }
                    setupLevel(true); return;
                }
            });
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                if (dist < player.size / 2 + enemy.size / 2) {
                    if (isPoweredUp) {
                        score += 20;
                        enemies.splice(i, 1);
                    } else {
                        handleLifeLost();
                        break; 
                    }
                }
            }

            if (powerUp) {
                const dist = Math.hypot(player.x - powerUp.x, player.y - powerUp.y);
                if (dist < player.size / 2 + powerUp.size / 2) {
                    if (powerUp.type === 'heart') {
                        lives++; updateHUD();
                    } else if (powerUp.type === 'trophy') {
                        isPoweredUp = true;
                        enemies.forEach(e => e.isVulnerable = true);
                        clearTimeout(powerUpTimer);
                        powerUpTimer = setTimeout(() => {
                            isPoweredUp = false;
                            enemies.forEach(e => e.isVulnerable = false);
                        }, 8000); // 8 seconds
                    }
                    powerUp = null;
                }
            }
        }
        
        function endGame(isWinner) {
            gameRunning = false;
            const gameEndTime = new Date();
            const gameDurationSeconds = Math.round((gameEndTime - gameStartTime) / 1000);

            gameContainer.style.display = 'none';
            endScreen.style.display = 'flex';
            
            endTitleEl.textContent = isWinner ? `Parabéns, ${playerName}!` : 'Fim de Jogo!';
            finalScoreEl.textContent = `Sua Pontuação: ${score}`;
            gameDurationEl.textContent = `Tempo de Jogo: ${gameDurationSeconds} segundos`;
            gameDateTimeEl.textContent = `Realizado em: ${gameEndTime.toLocaleDateString('pt-BR')} às ${gameEndTime.toLocaleTimeString('pt-BR')}`;
            
            const finalGameData = {
                date: gameEndTime.toLocaleString('pt-BR'),
                playerClass: document.getElementById('playerClass').value,
                playerName: playerName,
                score: score,
                time: gameDurationSeconds
            };

            sendDataToSheet(finalGameData);
            saveScoreToLocal(gameEndTime);
            displayLocalScores(leaderboardListEl, 5); // Mostra top 5 no final
        }
        
        async function sendDataToSheet(data) {
            if (!SCRIPT_URL) {
                console.log("URL do Apps Script não configurada. Dados não serão enviados.");
                return;
            }

            try {
                await fetch(SCRIPT_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
            } catch (error) {
                console.error("Erro ao enviar dados para a planilha:", error);
            }
        }

        function saveScoreToLocal(date) {
            const scoreData = { name: playerName, score: score, date: date.toISOString() };
            let highScores = JSON.parse(localStorage.getItem('adverbManHighScores')) || [];
            highScores.push(scoreData);
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 20); // Keep top 20
            localStorage.setItem('adverbManHighScores', JSON.stringify(highScores));
        }

        function displayLocalScores(listElement, limit) {
            let highScores = JSON.parse(localStorage.getItem('adverbManHighScores')) || [];
            listElement.innerHTML = '';
            if (highScores.length === 0) {
                listElement.innerHTML = '<li>Seja o primeiro a pontuar!</li>';
            } else {
                highScores.slice(0, limit).forEach(s => {
                    const li = document.createElement('li');
                    const scoreDate = new Date(s.date);
                    li.innerHTML = `<span class="score-name">${s.name}</span> <span>${s.score} pts (${scoreDate.toLocaleDateString('pt-BR')})</span>`;
                    listElement.appendChild(li);
                });
            }
        }

        function resetGame() { window.location.reload(); }

        function gameLoop() {
            if (!gameRunning) return;
            ctx.fillStyle = PATH_COLOR; ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            if (powerUp) { powerUp.draw(); }
            answers.forEach(answer => answer.draw());
            player.update(); player.draw();
            enemies.forEach(enemy => { enemy.update(); enemy.draw(); });
            checkCollisions();
            requestAnimationFrame(gameLoop);
        }

        // --- CONTROLS ---
        function handleKeyDown(e) {
            if (!player || !e || !e.key) return;
            if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') player.changeDirection(0, -1);
            else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') player.changeDirection(0, 1);
            else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') player.changeDirection(-1, 0);
            else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') player.changeDirection(1, 0);
        }
        function handleKeyUp(e) {
             if (!player || !e || !e.key) return;
             if (['arrowup', 'w', 'arrowdown', 's', 'arrowleft', 'a', 'arrowright', 'd'].includes(e.key.toLowerCase())) { player.changeDirection(0, 0); }
        }
        function setupMobileControls() {
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (isTouchDevice) {
                mobileControls.style.display = 'grid';
                const buttons = mobileControls.querySelectorAll('button');
                buttons.forEach(button => {
                    const press = (e) => {
                        e.preventDefault(); const direction = button.className;
                        if (direction === 'up') player.changeDirection(0, -1); if (direction === 'down') player.changeDirection(0, 1);
                        if (direction === 'left') player.changeDirection(-1, 0); if (direction === 'right') player.changeDirection(1, 0);
                    };
                    const release = (e) => { e.preventDefault(); player.changeDirection(0, 0); };
                    button.addEventListener('touchstart', press); button.addEventListener('mousedown', press);
                    button.addEventListener('touchend', release); button.addEventListener('mouseup', release);
                    button.addEventListener('mouseleave', release);
                });
            }
        }

        // --- INITIALIZATION ---
        function startGame() {
            playerName = playerNameInput.value || "Ana";
            gameStartTime = new Date();
            startScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            endScreen.style.display = 'none';
            rankingScreen.style.display = 'none';
            resizeCanvas();
            setupLevel(true);
            setupMobileControls();
            gameLoop();
        }

        async function showRanking() {
            startScreen.style.display = 'none';
            rankingScreen.style.display = 'flex';
            rankingListEl.innerHTML = '<li>Carregando ranking...</li>';

            if (!SCRIPT_URL) {
                rankingListEl.innerHTML = '<li>Ranking online indisponível.</li>';
                return;
            }

            try {
                const response = await fetch(SCRIPT_URL);
                const result = await response.json();

                if (result.status === "success") {
                    rankingListEl.innerHTML = '';
                    if (result.data.length === 0) {
                        rankingListEl.innerHTML = '<li>Nenhuma pontuação registrada ainda.</li>';
                    } else {
                        result.data.forEach(s => {
                            const li = document.createElement('li');
                            li.innerHTML = `<span class="score-name">${s.Nome}</span> <span>${s.Pontuação} pts</span>`;
                            rankingListEl.appendChild(li);
                        });
                    }
                } else {
                    rankingListEl.innerHTML = `<li>Erro ao carregar ranking.</li>`;
                }
            } catch (error) {
                console.error("Erro ao buscar ranking:", error);
                rankingListEl.innerHTML = '<li>Não foi possível conectar ao ranking.</li>';
            }
        }

        function showStartScreen() {
            startScreen.style.display = 'flex';
            rankingScreen.style.display = 'none';
        }

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', resetGame);
        rankingButton.addEventListener('click', showRanking);
        backToStartButton.addEventListener('click', showStartScreen);

        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        window.addEventListener('resize', () => { resizeCanvas(); });
        
    </script>
</body>
</html>
